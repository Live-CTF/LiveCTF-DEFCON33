use diesel::prelude::*;
use diesel::r2d2::{self, ConnectionManager};

use futures_util::StreamExt;

use log::{error, info, warn};
mod builder;
type DbPool = r2d2::Pool<ConnectionManager<PgConnection>>;
use deadpool_lapin::lapin::{
    options::BasicAckOptions, options::BasicConsumeOptions, types::FieldTable,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    dotenv::dotenv().ok();
    env_logger::init_from_env(env_logger::Env::new().default_filter_or("info"));

    let gcp_key =
        std::env::var("GOOGLE_SERVICE_ACCOUNT_KEY").expect("GOOGLE_SERVICE_ACCOUNT_KEY not set");

    if !std::path::Path::new("/credentials").exists() {
        std::fs::create_dir("/credentials").expect("Unable to create GCP credentials directory");
    }
    std::fs::write("/credentials/gcp.json", gcp_key).expect("Unable to write credentials to file");

    let amqp_addr = std::env::var("AMQP_ADDR").expect("AMQP_ADDR not set");
    let amqp_pool = {
        let cfg = deadpool_lapin::Config {
            url: Some(amqp_addr),
            ..Default::default()
        };
        cfg.create_pool(Some(deadpool_lapin::Runtime::Tokio1))
            .map_err(|err| std::io::Error::new(std::io::ErrorKind::ConnectionRefused, err))?
    };

    let db_pool = {
        let conn_spec = std::env::var("DATABASE_URL").expect("DATABASE_URL");
        common::setup_database_pool(&conn_spec).expect("Failed to connect to database")
    };
    let object_store = {
        let storage_type = std::env::var("EXPLOITS_STORAGE").expect("EXPLOITS_STORAGE not set");
        let exploits_path = std::env::var("EXPLOITS_PATH").expect("EXPLOITS_PATH not set");
        common::get_object_store(&storage_type, &exploits_path)
            .expect("Failed to setup object store")
    };
    let object_store_url_prefix = {
        let storage_type = std::env::var("EXPLOITS_STORAGE").expect("EXPLOITS_STORAGE not set");
        let exploits_path = std::env::var("EXPLOITS_PATH").expect("EXPLOITS_PATH not set");
        common::get_object_store_url_prefix(&storage_type, &exploits_path)
            .expect("Failed to setup object store URL prefix")
    };
    //let build_path = std::env::var("BUILD_PATH").expect("BUILD_PATH not set");
    let exploit_docker_repo =
        std::env::var("EXPLOIT_DOCKER_REPO").expect("EXPLOIT_DOCKER_REPO not set");
    let container_runner = std::env::var("CONTAINER_RUNNER").expect("CONTAINER_RUNNER not set");
    let disk_limit_available = std::env::var("DISK_LIMIT_AVAILABLE").is_ok();

    let connection = amqp_pool
        .get()
        .await
        .map_err(|err| std::io::Error::new(std::io::ErrorKind::ConnectionRefused, err))?;
    let channel = connection
        .create_channel()
        .await
        .map_err(|err| std::io::Error::new(std::io::ErrorKind::ConnectionRefused, err))?;
    channel
        .queue_declare(
            common::EXPLOIT_BUILD_QUEUE,
            lapin::options::QueueDeclareOptions::default(),
            lapin::types::FieldTable::default(),
        )
        .await
        .map_err(|err| std::io::Error::new(std::io::ErrorKind::ConnectionRefused, err))?;
    let mut consumer = channel
        .basic_consume(
            common::EXPLOIT_BUILD_QUEUE,
            "builder",
            BasicConsumeOptions::default(),
            FieldTable::default(),
        )
        .await?;

    // TODO(P0): handle build result
    // TODO(P0): configure ack settings
    // TODO(P0): replace TaskResult
    while let Some(delivery) = consumer.next().await {
        let delivery = delivery.expect("error in consumer");
        let build_uuid = match uuid::Uuid::from_slice(&delivery.data) {
            Ok(uuid) => uuid,
            Err(err) => {
                error!("Invalid UUID in worker queue, skipping: {err}"); // TODO(P2): print hex value of invalid data
                continue;
            }
        };
        match crate::builder::build_exploit(
            build_uuid,
            &db_pool,
            &amqp_pool,
            &object_store,
            &object_store_url_prefix,
            disk_limit_available,
            &exploit_docker_repo,
            &container_runner,
        )
        .await
        {
            Ok(()) => {
                info!("Finished processing build {build_uuid}");
            }
            Err(err) => {
                warn!("Error processing build {build_uuid}: {err}"); //TODO(P1): retry if applicable
            }
        };
        delivery.ack(BasicAckOptions::default()).await.expect("ack");
    }

    Ok(())
}
