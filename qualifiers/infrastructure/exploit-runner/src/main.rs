use diesel::prelude::*;
use diesel::r2d2::{self, ConnectionManager};

use futures_util::StreamExt;

use log::{error, info, warn};

type DbPool = r2d2::Pool<ConnectionManager<PgConnection>>;
use deadpool_lapin::lapin::{
    options::BasicAckOptions, options::BasicConsumeOptions, types::FieldTable,
};

mod runner;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    dotenv::dotenv().ok();
    env_logger::init_from_env(env_logger::Env::new().default_filter_or("info"));

    let db_pool = {
        let conn_spec = std::env::var("DATABASE_URL").expect("DATABASE_URL");
        common::setup_database_pool(&conn_spec).expect("Failed to connect to database")
    };
    let amqp_addr = std::env::var("AMQP_ADDR").expect("AMQP_ADDR not set");
    let amqp_pool = {
        let cfg = deadpool_lapin::Config {
            url: Some(amqp_addr),
            ..Default::default()
        };
        cfg.create_pool(Some(deadpool_lapin::Runtime::Tokio1))
            .map_err(|err| std::io::Error::new(std::io::ErrorKind::ConnectionRefused, err))?
    };

    let exploit_docker_repo =
        std::env::var("EXPLOIT_DOCKER_REPO").expect("EXPLOIT_DOCKER_REPO not set");

    let challenge_docker_repo =
        std::env::var("CHALLENGE_DOCKER_REPO").expect("CHALLENGE_DOCKER_REPO not set");

    let container_runner = std::env::var("CONTAINER_RUNNER").expect("CONTAINER_RUNNER not set");

    let disk_limit_available = std::env::var("DISK_LIMIT_AVAILABLE").is_ok();

    let connection = amqp_pool
        .get()
        .await
        .map_err(|err| std::io::Error::new(std::io::ErrorKind::ConnectionRefused, err))?;
    let channel = connection
        .create_channel()
        .await
        .map_err(|err| std::io::Error::new(std::io::ErrorKind::ConnectionRefused, err))?;
    channel
        .queue_declare(
            common::EXPLOIT_RUN_QUEUE,
            lapin::options::QueueDeclareOptions::default(),
            lapin::types::FieldTable::default(),
        )
        .await
        .map_err(|err| std::io::Error::new(std::io::ErrorKind::ConnectionRefused, err))?;
    let mut consumer = channel
        .basic_consume(
            common::EXPLOIT_RUN_QUEUE,
            "runner",
            BasicConsumeOptions::default(),
            FieldTable::default(),
        )
        .await?;

    // TODO(P0): handle build result
    // TODO(P0): configure ack settings
    // TODO(P0): replace TaskResult
    while let Some(delivery) = consumer.next().await {
        let delivery = delivery.expect("error in consumer");
        let run_uuid = match uuid::Uuid::from_slice(&delivery.data) {
            Ok(uuid) => uuid,
            Err(err) => {
                error!("Invalid UUID in runner worker queue, skipping: {err}"); // TODO(P2): print hex value of invalid data
                continue;
            }
        };
        match crate::runner::run_exploit(
            run_uuid,
            &db_pool,
            disk_limit_available,
            &exploit_docker_repo,
            &challenge_docker_repo,
            &container_runner,
        )
        .await
        {
            Ok(()) => {
                info!("Finished processing run {run_uuid}");
            }
            Err(err) => {
                warn!("Error processing run {run_uuid}: {err}"); //TODO(P1): retry if applicable
            }
        };
        delivery.ack(BasicAckOptions::default()).await.expect("ack");
    }

    Ok(())
}
