use diesel::prelude::*;
use log::{info, warn};
use nix::sys::signal::{self, Signal};
use nix::unistd::Pid;
use std::time::Duration;
use std::time::Instant;
use tokio::task;
use uuid::Uuid;

use common::models::{Exploit, ExploitStatus};

use common::models::{Challenge, ChallengeId, ExploitOutput};

#[derive(PartialEq)]
enum NetworkDelete {
    Force,
    NoForce,
}

use std::fmt;

pub enum RunError {
    ErrorRetry(String),
    ErrorFail(String),
}

impl fmt::Display for RunError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            RunError::ErrorRetry(err) => write!(f, "{}", err),
            RunError::ErrorFail(err) => write!(f, "{}", err),
        }
    }
}

const SECRET_PREFIX: &str = "b4f31f6edb2fdec8";
const EXPLOIT_MEMORY: &str = "2g";
const EXPLOIT_CPU: f32 = 1.0;
const EXPLOIT_DISK: &str = "10g";
const CHALLENGE_MEMORY: &str = "2g";
const CHALLENGE_CPU: f32 = 1.0;
const CHALLENGE_DISK: &str = "10g";
const EXPLOIT_MAX_SECONDS: u64 = 240;
const MAX_RETRIES: usize = 5;

fn create_network(
    exploit: &Exploit,
    network_name: &str,
    container_runner: &str,
) -> Result<(), RunError> {
    let mut exploit_network_up = std::process::Command::new(container_runner)
        .args([
            "network",
            "create",
            "--internal",
            "--driver",
            "bridge",
            network_name,
        ])
        .spawn()
        .map_err(|err| {
            RunError::ErrorRetry(format!(
                "Exploit {}, failed to spawn Docker create network: {}",
                exploit.exploit_id(),
                err
            ))
        })?;

    let network_up_status = exploit_network_up.wait().map_err(|err| {
        RunError::ErrorRetry(format!(
            "Exploit {}, failed to execute Docker network create: {}",
            exploit.exploit_id(),
            err
        ))
    })?;
    if !network_up_status.success() {
        return Err(RunError::ErrorRetry(format!(
            "Exploit {}, Docker network create, non-zero exit status",
            exploit.exploit_id()
        )));
    }

    Ok(())
}

fn fetch_exploit(exploit_uuid: Uuid, db_pool: &crate::DbPool) -> Result<Exploit, RunError> {
    use common::schema::exploits::dsl::*;
    let mut conn = db_pool
        .get()
        .map_err(|err| RunError::ErrorRetry(err.to_string()))?;
    match exploits
        .filter(exploit_id.eq(exploit_uuid))
        .first::<Exploit>(&mut conn)
        .optional()
        .map_err(|err| RunError::ErrorRetry(err.to_string()))?
    {
        Some(exploit) => Ok(exploit),
        None => Err(RunError::ErrorFail(format!(
            "Unable to find exploit with id {exploit_uuid}"
        ))),
    }
}

fn fetch_challenge(
    fetch_challenge_id: &ChallengeId,
    db_pool: &crate::DbPool,
) -> Result<Challenge, RunError> {
    use common::schema::challenges::dsl::*;
    let mut conn = db_pool
        .get()
        .map_err(|err| RunError::ErrorRetry(err.to_string()))?;
    match challenges
        .filter(challenge_id.eq(fetch_challenge_id))
        .first::<Challenge>(&mut conn)
        .optional()
        .map_err(|err| RunError::ErrorRetry(err.to_string()))?
    {
        Some(challenge) => Ok(challenge),
        None => Err(RunError::ErrorFail(format!(
            "Unable to find challenge with id {fetch_challenge_id}"
        ))),
    }
}

fn pull_exploit_image(
    exploit: &Exploit,
    exploit_image_tag: &str,
    container_runner: &str,
) -> Result<(), RunError> {
    let mut exploit_pull = std::process::Command::new(container_runner)
        .args(["pull", exploit_image_tag])
        .spawn()
        .map_err(|err| {
            RunError::ErrorRetry(format!(
                "Exploit {}, failed to spawn Docker pull exploit: {}",
                exploit.exploit_id(),
                err
            ))
        })?;
    let exploit_pull_status = exploit_pull.wait().map_err(|err| {
        RunError::ErrorRetry(format!(
            "Exploit {}, failed to execute Docker pull exploit: {}",
            exploit.exploit_id(),
            err
        ))
    })?;
    if !exploit_pull_status.success() {
        return Err(RunError::ErrorRetry(format!(
            "Exploit {}, Docker pull exploit, non-zero exit status",
            exploit.exploit_id()
        )));
    }

    Ok(())
}

fn pull_challenge_image(
    exploit: &Exploit,
    challenge_image_tag: &str,
    container_runner: &str,
) -> Result<(), RunError> {
    let mut challenge_pull = std::process::Command::new(container_runner)
        .args(["pull", challenge_image_tag])
        .spawn()
        .map_err(|err| {
            RunError::ErrorRetry(format!(
                "Exploit {}, failed to spawn Docker pull challenge {}: {}",
                exploit.exploit_id(),
                challenge_image_tag,
                err
            ))
        })?;
    let challenge_pull_status = challenge_pull.wait().map_err(|err| {
        RunError::ErrorRetry(format!(
            "Exploit {}, failed to execute Docker pull challenge {}: {}",
            exploit.exploit_id(),
            challenge_image_tag,
            err
        ))
    })?;
    if !challenge_pull_status.success() {
        return Err(RunError::ErrorRetry(format!(
            "Exploit {}, Docker pull challenge {}, non-zero exit status",
            exploit.exploit_id(),
            challenge_image_tag
        )));
    }

    Ok(())
}

fn delete_exploit_image(
    exploit: &Exploit,
    exploit_image_tag: &str,
    container_runner: &str,
) -> Result<(), RunError> {
    let mut exploit_clean = std::process::Command::new(container_runner)
        .args(["rmi", exploit_image_tag])
        .spawn()
        .map_err(|err| {
            RunError::ErrorRetry(format!(
                "Exploit {}, failed to spawn Docker rmi exploit: {}",
                exploit.exploit_id(),
                err
            ))
        })?;

    let clean_status = exploit_clean
        .wait()
        .map_err(|err| RunError::ErrorRetry(format!("Failed to execute Docker rmi: {err}")))?;
    if !clean_status.success() {
        return Err(RunError::ErrorRetry(format!(
            "Exploit {}, Docker rmi exploit, non-zero exit status",
            exploit.exploit_id()
        )));
    }

    Ok(())
}

fn stop_challenge(
    exploit: &Exploit,
    challenge_container_name: &str,
    container_runner: &str,
) -> Result<(), RunError> {
    let mut challenge_stop = std::process::Command::new(container_runner)
        .args(["stop", challenge_container_name])
        .spawn()
        .expect("failed to execute stop process");

    let challenge_stop_status = challenge_stop
        .wait()
        .map_err(|err| RunError::ErrorRetry(format!("Failed to execute Docker stop: {err}")))?;
    if !challenge_stop_status.success() {
        return Err(RunError::ErrorRetry(format!(
            "Exploit {}, Docker stop challenge, non-zero exit status",
            exploit.exploit_id()
        )));
    }

    Ok(())
}

fn delete_network(
    exploit: &Exploit,
    network_name: &str,
    force: &NetworkDelete,
    container_runner: &str,
) -> Result<(), RunError> {
    let mut exploit_network_command = std::process::Command::new(container_runner);
    exploit_network_command.args(["network", "rm", network_name]);
    if *force == NetworkDelete::Force {
        exploit_network_command.arg("-f");
    }

    let mut exploit_network_down = exploit_network_command.spawn().map_err(|err| {
        RunError::ErrorRetry(format!(
            "Exploit {}, failed to spawn Docker network rm: {}",
            exploit.exploit_id(),
            err
        ))
    })?;

    let network_down_status = exploit_network_down.wait().map_err(|err| {
        RunError::ErrorRetry(format!("Failed to execute Docker network rm: {err}"))
    })?;
    if !network_down_status.success() {
        return Err(RunError::ErrorRetry(format!(
            "Exploit {}, Docker network rm, non-zero exit status",
            exploit.exploit_id()
        )));
    }

    Ok(())
}

// TODO (P0): Make sure you can't guess the challenge image name ahead of release
fn run_challenge(
    exploit: &Exploit,
    challenge_image_tag: &str,
    challenge_container_name: &str,
    network_name: &str,
    uses_nsjail: &bool,
    challenge_flag: &str,
    container_runner: &str,
    disk_limit_available: bool,
) -> Result<(), RunError> {
    let mut challenge_command = std::process::Command::new(container_runner);
    challenge_command.args([
        "run",
        "-d",
        "--rm",
        &format!("--cpus={CHALLENGE_CPU}"),
        &format!("--memory={CHALLENGE_MEMORY}"),
        "--log-driver",
        "passthrough",
        "--network",
        network_name,
        "--name",
        challenge_container_name,
        "-e",
        &format!("FLAG={challenge_flag}"),
    ]);

    if disk_limit_available {
        challenge_command.args(["--storage-opt", &format!("size={CHALLENGE_DISK}")]);
    } else {
        log::warn!("Not limiting available disk space for challenge container");
    }

    if *uses_nsjail {
        challenge_command.arg("--privileged");
    }

    let challenge_run = &mut challenge_command
        .arg(challenge_image_tag)
        .spawn()
        .map_err(|err| {
            RunError::ErrorRetry(format!(
                "Exploit {}, failed to spawn Docker run challenge: {}",
                exploit.exploit_id(),
                err
            ))
        })?;

    let challenge_run_status = challenge_run.wait().map_err(|err| {
        RunError::ErrorRetry(format!(
            "Exploit {}, failed to execute Docker run challenge: {}",
            exploit.exploit_id(),
            err
        ))
    })?;
    if !challenge_run_status.success() {
        return Err(RunError::ErrorRetry(format!(
            "Exploit {}, Docker run challenge, non-zero exit status",
            exploit.exploit_id()
        )));
    }

    Ok(())
}

fn update_exploit_status_running(
    exploit: &Exploit,
    db_pool: &crate::DbPool,
) -> Result<(), RunError> {
    use common::schema::exploits::dsl::*;
    let mut conn = db_pool
        .get()
        .map_err(|err| RunError::ErrorRetry(err.to_string()))?;
    diesel::update(&exploit)
        .set(status.eq(ExploitStatus::Running))
        .execute(&mut conn)
        .map_err(|err| RunError::ErrorRetry(err.to_string()))?;

    Ok(())
}

fn update_exploit_status_run(
    exploit: &Exploit,
    exploit_result: Option<std::time::Duration>,
    run_stdout: &str,
    run_stderr: &str,
    db_pool: &crate::DbPool,
) -> Result<(), RunError> {
    use common::schema::exploit_outputs::dsl::*;
    use common::schema::exploits::dsl::*;
    let mut conn = db_pool
        .get()
        .map_err(|err| RunError::ErrorRetry(err.to_string()))?;
    let update = diesel::update(&exploit);

    let update = match exploit_result {
        Some(duration) => update.set((
            status.eq(ExploitStatus::RunSolved),
            pending.eq(None::<bool>),
            run_duration.eq(Some(i32::try_from(duration.as_secs()).map_err(|err| {
                RunError::ErrorFail(format!(
                    "Exploit {}, duration does not fit in 32-bit integer: {}",
                    exploit.exploit_id(),
                    err
                ))
            })?)),
        )),

        None => update.set((
            status.eq(ExploitStatus::RunFailed),
            pending.eq(None::<bool>),
            run_duration.eq(None::<i32>),
        )),
    };

    update
        .execute(&mut conn)
        .map_err(|err| RunError::ErrorRetry(err.to_string()))?;

    let exploit_output = ExploitOutput::new(
        *exploit.exploit_id(),
        run_stdout.to_string(),
        run_stderr.to_string(),
    );

    diesel::insert_into(exploit_outputs)
        .values(&exploit_output)
        .execute(&mut conn)
        .map_err(|err| RunError::ErrorRetry(err.to_string()))?;

    Ok(())
}

async fn do_run_exploit(
    exploit: &Exploit,
    challenge: &Challenge,
    container_runner: &str,
    exploit_docker_repo: &str,
    challenge_docker_repo: &str,
    disk_limit_available: bool,
) -> Result<(Option<std::time::Duration>, String, String), RunError> {
    let network_name = &format!("{}-net", exploit.exploit_id());

    let exploit_image_tag = &format!("{}{}:latest", exploit_docker_repo, exploit.archive_id());
    let challenge_image_tag = &format!(
        "{}{}-{}:latest",
        challenge_docker_repo,
        SECRET_PREFIX,
        challenge.challenge_name(),
    );

    let challenge_container_name = &format!("{}-challenge", exploit.exploit_id());
    let exploit_container_name = &format!("{}-exploit", exploit.exploit_id());

    let challenge_flag = format!("LiveCTF{{{}}}", Uuid::new_v4());

    delete_network(
        exploit,
        network_name,
        &NetworkDelete::Force,
        container_runner,
    )?;
    // TODO (P2): clean up network on early error
    create_network(exploit, network_name, container_runner)?;

    log::info!("Pulling exploit container {}", exploit_image_tag);
    pull_exploit_image(exploit, exploit_image_tag, container_runner)?;

    log::info!("Pulling challenge container {}", challenge_image_tag);
    pull_challenge_image(exploit, challenge_image_tag, container_runner)?;

    log::info!("Running challenge {}", challenge_image_tag);
    run_challenge(
        exploit,
        challenge_image_tag,
        challenge_container_name,
        network_name,
        challenge.uses_nsjail(),
        &challenge_flag,
        container_runner,
        disk_limit_available,
    )?;

    log::info!(
        "Running exploit container {} for challenge {}",
        exploit_container_name,
        challenge_image_tag
    );
    let exploit_start = Instant::now();
    let mut exploit_command = async_process::Command::new(container_runner);

    exploit_command
        .stderr(async_process::Stdio::piped())
        .stdout(async_process::Stdio::piped())
        .args([
            "run",
            "--init",
            "--rm",
            &format!("--cpus={EXPLOIT_CPU}"),
            &format!("--memory={EXPLOIT_MEMORY}"),
            "--log-driver",
            "passthrough",
            "--network",
            network_name,
            "--cap-add=CAP_PERFMON", // TODO(P2): reconsider, this was used for an instruction counting challenge
            "--name",
            exploit_container_name,
            "-e",
            &format!("HOST={challenge_container_name}"),
        ]);

    if disk_limit_available {
        exploit_command.args(["--storage-opt", &format!("size={EXPLOIT_DISK}")]);
    } else {
        log::warn!("Not limiting available disk space for exploit container");
    }

    exploit_command.arg(exploit_image_tag);
    let mut exploit_run = exploit_command.spawn().map_err(|err| {
        RunError::ErrorRetry(format!(
            "Exploit {}, failed to spawn exploit: {}",
            exploit.exploit_id(),
            err
        ))
    })?;

    let (exploit_success, stdout, stderr) = match tokio::time::timeout(
        Duration::from_secs(EXPLOIT_MAX_SECONDS),
        exploit_run.status(),
    )
    .await
    {
        Err(err) => {
            match exploit_run.id().try_into() {
                Err(_) => {
                    log::warn!(
                        "Exploit {}, run time limit exceeded: {}, failed to get process pid",
                        exploit.exploit_id(),
                        err
                    );
                }
                Ok(pid) => {
                    match signal::kill(Pid::from_raw(pid), Signal::SIGTERM) {
                        Ok(()) => {
                            log::info!(
                                "Exploit {}, run time limit exceeded: {}",
                                exploit.exploit_id(),
                                err
                            );
                        }
                        Err(_) => {
                            log::warn!(
                                "Exploit {}, run time limit exceeded: {}, failed to kill process",
                                exploit.exploit_id(),
                                err
                            );
                        }
                    };
                }
            };

            (None, String::from(""), String::from(""))
        }
        Ok(_) => {
            let exploit_run_ok = exploit_run.output().await.map_err(|err| {
                RunError::ErrorRetry(format!(
                    "Exploit {}, failed to get exploit output: {}",
                    exploit.exploit_id(),
                    err
                ))
            })?;

            let stdout = {
                let stdout: String = String::from_utf8_lossy(&exploit_run_ok.stdout)
                    .chars()
                    .filter(|c| *c != '\0')
                    .take(1024)
                    .collect();

                if stdout.len() == 1024 {
                    format!("{stdout}... (truncated to 1024 bytes)")
                } else {
                    stdout
                }
            };
            let stderr = {
                let stderr: String = String::from_utf8_lossy(&exploit_run_ok.stderr)
                    .chars()
                    .filter(|c| *c != '\0')
                    .take(1024)
                    .collect();

                if stderr.len() == 1024 {
                    format!("{stderr}... (truncated to 1024 bytes)")
                } else {
                    stderr
                }
            };
            info!("Exploit stdout: {}", stdout);
            info!("Exploit stderr: {}", stderr);

            let flag_bytes = challenge_flag.as_bytes();
            let exploit_success = if exploit_run_ok
                .stdout
                .windows(flag_bytes.len())
                .any(|window| window == flag_bytes)
            {
                Some(exploit_start.elapsed())
            } else {
                None
            };

            (exploit_success, stdout, stderr)
        }
    };

    stop_challenge(exploit, challenge_container_name, container_runner)?;
    if let Err(err) = delete_exploit_image(exploit, exploit_image_tag, container_runner) {
        warn!("Failed to delete exploit image {exploit_image_tag}: {err}");
    }
    // TODO (P2): remove network regardless of when function exits
    if let Err(err) = delete_network(
        exploit,
        network_name,
        &NetworkDelete::NoForce,
        container_runner,
    ) {
        warn!("Failed to delete exploit network {network_name}: {err}");
    };

    Ok((exploit_success, stdout, stderr))
}

pub async fn run_exploit(
    exploit_uuid: Uuid,
    db_pool: &crate::DbPool,
    disk_limit_available: bool,
    exploit_docker_repo: &str,
    challenge_docker_repo: &str,
    container_runner: &str,
) -> Result<(), RunError> {
    info!("Going to run exploit {}", exploit_uuid);

    let exploit_to_run = fetch_exploit(exploit_uuid, db_pool)?;
    if *exploit_to_run.status() == ExploitStatus::Cancelled {
        return Ok(());
    }

    update_exploit_status_running(&exploit_to_run, db_pool)?;

    let challenge = fetch_challenge(exploit_to_run.challenge_id(), db_pool)?;

    // TODO(P2): make this less ugly
    let mut attempt = 0;
    let (success, stdout, stderr): (Option<std::time::Duration>, String, String) = loop {
        attempt += 1;
        let run_result = task::block_in_place(|| {
            do_run_exploit(
                &exploit_to_run,
                &challenge,
                container_runner,
                exploit_docker_repo,
                challenge_docker_repo,
                disk_limit_available,
            )
        })
        .await;

        match run_result {
            Ok((success, stdout, stderr)) => break Ok((success, stdout, stderr)),
            Err(run_error) => {
                if attempt < MAX_RETRIES {
                    continue;
                } else {
                    update_exploit_status_run(&exploit_to_run, None, "", "", db_pool)?;
                    break Err(run_error);
                }
            }
        }
    }?;

    // Check one final time if it was cancelled before end of run
    if *exploit_to_run.status() == ExploitStatus::Cancelled {
        return Ok(());
    }
    update_exploit_status_run(&exploit_to_run, success, &stdout, &stderr, db_pool)?;

    Ok(())
}
