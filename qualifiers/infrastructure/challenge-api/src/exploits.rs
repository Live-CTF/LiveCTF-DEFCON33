use actix_web::{get, web, HttpResponse};
use deadpool_lapin::lapin::{options::BasicPublishOptions, BasicProperties};
use uuid::Uuid;

use crate::actions;
use crate::models;

use crate::error::ApiError;
use crate::AppState;
use crate::DbPool;

pub fn exploits_service() -> actix_web::Scope {
    web::scope("/exploits")
        .service(get_exploits)
        .service(get_exploit)
        .service(get_exploit_output)
        .service(rerun_exploit)
}

#[get("/")]
pub async fn get_exploits(
    pool: web::Data<DbPool>,
    app_state: web::Data<AppState>,
    admin_token: web::Header<models::AdminTokenHeader>,
) -> Result<HttpResponse, ApiError> {
    let admin_token = admin_token.into_inner();
    admin_token.validate(&app_state.admin_key)?;

    let exploits = web::block(move || {
        let mut conn = pool.get()?;
        actions::admin_get_exploits(&mut conn)
    })
    .await??;

    Ok(HttpResponse::Ok().json(exploits))
}

#[get("/{exploit_id}/output")]
pub async fn get_exploit_output(
    pool: web::Data<DbPool>,
    redis: web::Data<redis::Client>,
    app_state: web::Data<AppState>,
    exploit_id: web::Path<Uuid>,
    team_token: web::Header<models::AuthenticationTokenHeader>,
) -> Result<HttpResponse, ApiError> {
    let exploit_id = exploit_id.into_inner();
    let team_token = team_token.into_inner();
    let app_state = app_state.into_inner();
    let team_info = team_token
        .validate(
            &redis,
            &app_state.auth_server_url,
            &app_state.auth_server_key,
            None,
        )
        .await?;

    let exploit_output = web::block(move || {
        let mut conn = pool.get()?;
        actions::get_exploit_output(&mut conn, exploit_id)
    })
    .await??;

    match exploit_output {
        Some((exploit, output)) if *exploit.team_id() == *team_info.team_id() => {
            Ok(HttpResponse::Ok().json(output))
        }
        Some((exploit, _)) => Err(ApiError::ExploitForbidden {
            team_id: *team_info.team_id(),
            exploit_id: *exploit.exploit_id(),
        }),
        None => Err(ApiError::ExploitNotFound { exploit_id }),
    }
}

#[get("/{exploit_id}")]
pub async fn get_exploit(
    pool: web::Data<DbPool>,
    redis: web::Data<redis::Client>,
    app_state: web::Data<AppState>,
    exploit_id: web::Path<Uuid>,
    team_token: web::Header<models::AuthenticationTokenHeader>,
) -> Result<HttpResponse, ApiError> {
    let exploit_id = exploit_id.into_inner();
    let team_token = team_token.into_inner();
    let app_state = app_state.into_inner();
    let team_info = team_token
        .validate(
            &redis,
            &app_state.auth_server_url,
            &app_state.auth_server_key,
            None,
        )
        .await?;

    let exploit = web::block(move || {
        let mut conn = pool.get()?;
        actions::get_exploit(&mut conn, exploit_id)
    })
    .await??;

    match exploit {
        Some(exploit) if *exploit.team_id() == *team_info.team_id() => {
            Ok(HttpResponse::Ok().json(exploit))
        }
        Some(exploit) => Err(ApiError::ExploitForbidden {
            team_id: *team_info.team_id(),
            exploit_id: *exploit.exploit_id(),
        }),
        None => Err(ApiError::ExploitNotFound { exploit_id }),
    }
}

#[get("/{exploit_id}/rerun")]
pub async fn rerun_exploit(
    app_state: web::Data<AppState>,
    amqp_pool: web::Data<deadpool_lapin::Pool>,
    pool: web::Data<DbPool>,
    exploit_id: web::Path<Uuid>,
    admin_token: web::Header<models::AdminTokenHeader>,
) -> Result<HttpResponse, ApiError> {
    let exploit_id = exploit_id.into_inner();
    let admin_token = admin_token.into_inner();
    admin_token.validate(&app_state.admin_key)?;

    let exploit = web::block(move || {
        let mut conn = pool.get()?;
        actions::get_exploit(&mut conn, exploit_id)
    })
    .await??;

    match exploit {
        Some(exploit) => {
            let connection = amqp_pool.get().await?;
            let channel = connection.create_channel().await?;
            channel
                .basic_publish(
                    "",
                    common::EXPLOIT_BUILD_QUEUE,
                    BasicPublishOptions::default(),
                    exploit.exploit_id().as_bytes(),
                    BasicProperties::default(),
                )
                .await?;

            Ok(HttpResponse::Ok().json(exploit))
        }
        None => Err(ApiError::ExploitNotFound { exploit_id }),
    }
}
