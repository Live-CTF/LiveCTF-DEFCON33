#!/usr/bin/env python3

from pwn import *
import os, re, subprocess

HOST = os.environ.get('HOST', 'localhost')
PORT = 31337

io = remote(HOST, int(PORT))

def solve(binary):
    pass

NUM_ROUNDS = 10

chal_path = "/tmp/chal"
gdb_script_path = "/tmp/gdbscript"

for _ in range(NUM_ROUNDS):
    io.recvuntil(b"Round ")
    print(io.recvline())

    io.recvuntil(b"Watchme: ")
    challenge_b64 = io.recvline()
    challenge = b64d(challenge_b64)

    with open(chal_path, "wb") as chal:
        chal.write(challenge)
    os.system(f"chmod +x {chal_path}")

    exe = ELF(chal_path, False)

    funcs = list(exe.sym.keys())
    good_funcs = [func for func in funcs if "_" in func and len(set(func.split("_")[1])) == 1]
    #  print(good_funcs)

    gdb_script = ""

    for func in good_funcs:
        c = list(set(func.split("_")[1]))[0]
        gdb_script += f"break {func}\n"
        gdb_script += f"commands\n"
        gdb_script += f"c\n"
        gdb_script += f"end\n"

    gdb_script += "run\n"
    gdb_script += "quit\n"

    with open(gdb_script_path, "w") as f:
        f.write(gdb_script)

    data = subprocess.check_output("gdb -q -x /tmp/gdbscript /tmp/chal".split())
    m = re.findall(b"func_[A-Za-z0-9]{10,10}", data)
    #  print(m)
    flag = bytes(x[-1] for x in m)
    print(flag)

    assert flag.startswith(b"PASS")
    flag = b"PASS{" + flag[4:] + b"}"

    io.sendline(flag)

    result = io.recvline()
    print(result)
    if b"Incorrect" in result:
        break

print(io.recvline())

#  io.interactive()
