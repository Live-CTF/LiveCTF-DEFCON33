import logging
import re
import sys

import angr
import claripy
from z3 import *

logging.getLogger('angr').setLevel(logging.CRITICAL + 1)

expr_pat = re.compile(
    r"\(if (.*?) == (.*?) then (.*?) else (.*?)\)", re.DOTALL,
)
var_pat = re.compile(r'\([0-9_char:\[\] .]+\)')
hibit_pat = re.compile(r' && flag\[\d+\]\[7:7\] == flag\[\d+\]\[7:7\] then')

def simplify_all_expressions(text: str):
    for match in var_pat.finditer(text):
        identifiers = re.findall(r"char_\d+_\d+_\d+", match.group(0))
        text = text.replace(match.group(0), identifiers[0])

    for i, arg in enumerate(arg_chars):
        text = text.replace(arg._encoded_name.decode(), f'flag[{i}]')

    text = re.sub(hibit_pat, ' then', text)
    #text = text.replace('&&', 'and')
    results = []
    for match in expr_pat.finditer(text):
        lhs, rhs, then_val, else_val = match.groups()
        assert then_val == '0' and else_val == '1'

        results.append(f"{lhs} == {rhs}")

    return results

def solve(constrs):
    solver = Solver()
    flag = [BitVec(f'flag_{i}', 8) for i in range(16)]

    for c in constrs:
        solver.add(eval(c))

    for i in range(16):
        solver.add(flag[i] >= 32)
        solver.add(flag[i] <= 126)

    if solver.check() == sat:
        model = solver.model()
        result = ''.join([chr(model[flag[i]].as_long()) for i in range(16)])
        print(result)

# Load the binary
project = angr.Project(sys.argv[1])

# Create a symbolic 16-character input (each character is a symbolic 8-bit value)
arg_size = 16
arg_chars = [claripy.BVS(f'char_{i}', 8) for i in range(arg_size)]
symbolic_str = claripy.Concat(*arg_chars)

# Allocate memory for the string and write the symbolic string there
state = project.factory.blank_state()

# Allocate memory for the input string on heap or some writable memory
input_addr = 0x800000  # arbitrary memory location
state.memory.store(input_addr, symbolic_str)

# Set rdi to point to our input string
state.regs.rsp = 0xdead00
state.memory.store(0xdead00, b'\0' * 8)
state.regs.rbp = 0xdeadbeef
state.regs.rdi = input_addr

# Set up the state at the function address
FUNC_ADDR = 0x40131A  # change this to your target function address
state.ip = FUNC_ADDR

# Set up simulation manager
simgr = project.factory.simgr(state)

# Define success condition: function returns 1 (in rax)
def is_successful(state):
    return state.solver.eval(state.regs.rsp) == 0xdead08 #and state.solver.eval(state.regs.rax) == 1

# Step until we reach a return (or some reasonable limit)
simgr.explore(find=is_successful)

if simgr.found:
    found = simgr.found[0]
    concrete_input = found.solver.eval(symbolic_str, cast_to=bytes)
    #print(f"[+] Found valid input: {concrete_input}")
    #print('\n'.join(simplify_all_expressions(repr(found.regs.rax))))
    solve(simplify_all_expressions(repr(found.regs.rax)))
else:
    print("[-] No valid input found.")