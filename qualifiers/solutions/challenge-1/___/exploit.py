from capstone import *
import os

from base64 import b64decode
from pwn import remote

HOST = os.environ.get('HOST', 'localhost')
PORT = 31337

with remote(HOST, int(PORT)) as r:
    for x in range(20):
        print(r.recvuntil(b'Crackme: '))
        binary = r.recvline()
        binary_raw = b64decode(binary)
        with open('/tmp/chall', 'wb') as f:
            f.write(binary_raw)
        os.chmod('/tmp/chall', 0o777)


        n = 19
        # data = open(f'challenge_{n}', 'rb').read()
        data = open(f'/tmp/chall', 'rb').read()

        start = 0x3010
        cs = Cs(CS_ARCH_X86, CS_MODE_64)

        insts = []
        i = 0
        while True:
            addr = start + i
            addr = int.from_bytes(data[addr:addr+8], 'little')
            if addr == 0:
                break
            if addr > 0x10000:
                break

            # print(hex(addr))
            func = data[addr:addr+100]
            func_insts = []
            for inst in cs.disasm(func, addr):
                func_insts.append(inst)
                if inst.mnemonic == 'ret':
                    break
            
            for inst in func_insts[1:-2]:
                # print(f'0x{inst.address:x}:\t{inst.mnemonic}\t{inst.op_str}')
                insts.append(inst)
            
            # insts.append(func_insts[-1])
            
            
            i += 8

        from z3 import *
        s = Solver()
        inputs = [z3.BitVec(f'input_{i}', 16) for i in range(16)]

        for inp in inputs:
            # s.add(inp >= 0x20)
            # s.add(inp <= 0x7e)
            s.add(Or(
                And(inp >= 0x41, inp <= 0x5a), # A-Z
                And(inp >= 0x61, inp <= 0x7a), # a-z
                And(inp >= 0x30, inp <= 0x39), # 0-9
                # inp == ord('+'),
                # inp == ord('/'),
            ))

        eax = None
        edx = None
        offset = 0
        for inst in insts:
            # print(f'{inst.mnemonic} {inst.op_str}')
            # if inst.mnemonic == 'ret':
            #     print()

            inst_str = f'{inst.mnemonic} {inst.op_str}' 
            if inst_str == 'mov rax, qword ptr [rbp - 0x18]':
                offset = 0
            elif inst_str.startswith('add rax,'):
                offset = int(inst_str.split(',')[1].strip(), 0)
            elif 'byte ptr [rax]' in inst_str:
                reg = inst_str.split(' ')[1].split(',')[0]
                if reg == 'eax':
                    eax = inputs[offset]
                elif reg == 'edx':
                    edx = inputs[offset]
            elif inst_str == 'movsx edx, al':
                edx = eax
            elif inst_str == 'movzx eax, dx':
                eax = edx
            # conditions
            elif inst_str == 'imul eax, edx':
                eax = eax * edx
            elif inst_str == 'add eax, edx':
                eax = eax + edx
            elif inst_str == 'xor eax, edx':
                eax = eax ^ edx
            elif inst_str == 'sub edx, eax':
                edx = edx - eax
            # cmps
            elif inst_str.startswith('cmp eax,'):
                cmp_val = int(inst_str.split(',')[1].strip(), 0)
                # print(f'z3cmp {eax} {cmp_val}')
                s.add(eax == cmp_val)
            elif inst_str.startswith('cmp edx,'):
                cmp_val = int(inst_str.split(',')[1].strip(), 0)
                # print(f'z3cmp {edx} {cmp_val}')
                s.add(edx == cmp_val)

        if s.check() == sat:
            m = s.model()
            print(''.join([chr(m[i].as_long()) for i in inputs]))
            r.sendline(''.join([chr(m[i].as_long()) for i in inputs]))
        else:
            print('no solution')
    
    print(r.recv(2048))
    print(r.recv(2048))